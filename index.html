<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Connect Four â€“ German Modal Verbs</title>
<link rel="manifest" href="manifest.json">
  <link rel="manifest" href="manifest.json">
<style>
body {
  font-family: Arial, sans-serif;
  text-align: center;
  background: #f4f6f9;
  margin: 0;
}

h1 {
  margin-top: 20px;
}

#board {
  display: grid;
  grid-template-columns: repeat(7, 70px);
  gap: 6px;
  justify-content: center;
  margin: 20px auto;
}

.cell {
  width: 70px;
  height: 70px;
  background: white;
  border-radius: 50%;
  border: 2px solid #333;
  cursor: pointer;
}

.player1 { background: #e74c3c; }
.player2 { background: #f1c40f; }

#questionModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  display: none;
  align-items: center;
  justify-content: center;
}

.modalContent {
  background: white;
  padding: 25px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
}

.optionBtn {
  display: block;
  width: 100%;
  margin: 8px 0;
  padding: 10px;
  font-size: 16px;
  cursor: pointer;
}

#status {
  font-size: 18px;
  margin-top: 10px;
}
</style>
</head>

<body>

<h1>Connect Four â€“ German Modal Verbs</h1>
<div id="status">Player 1's turn</div>
<div id="board"></div>

<div id="questionModal">
  <div class="modalContent">
    <h2 id="questionText"></h2>
    <div id="options"></div>
  </div>
</div>

<script>
// ===============================
// German Modal Verb Engine
// ===============================

const modalConjugations = [
  {verb:"dÃ¼rfen", forms:[["ich","darf"],["du","darfst"],["er/sie/es","darf"],["wir","dÃ¼rfen"],["ihr","dÃ¼rft"],["sie/Sie","dÃ¼rfen"]]},
  {verb:"kÃ¶nnen", forms:[["ich","kann"],["du","kannst"],["er/sie/es","kann"],["wir","kÃ¶nnen"],["ihr","kÃ¶nnt"],["sie/Sie","kÃ¶nnen"]]},
  {verb:"mÃ¶gen", forms:[["ich","mag"],["du","magst"],["er/sie/es","mag"],["wir","mÃ¶gen"],["ihr","mÃ¶gt"],["sie/Sie","mÃ¶gen"]]},
  {verb:"mÃ¼ssen", forms:[["ich","muss"],["du","musst"],["er/sie/es","muss"],["wir","mÃ¼ssen"],["ihr","mÃ¼sst"],["sie/Sie","mÃ¼ssen"]]},
  {verb:"sollen", forms:[["ich","soll"],["du","sollst"],["er/sie/es","soll"],["wir","sollen"],["ihr","sollt"],["sie/Sie","sollen"]]},
  {verb:"wollen", forms:[["ich","will"],["du","willst"],["er/sie/es","will"],["wir","wollen"],["ihr","wollt"],["sie/Sie","wollen"]]}
];

// Utility
const $ = s => document.querySelector(s);
const $$ = s => [...document.querySelectorAll(s)];
const shuffle = arr => arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
function toast(msg, ms=1400){const t=$('#toast');const div=document.createElement('div');div.textContent=msg;t.appendChild(div);setTimeout(()=>div.remove(),ms);}

// ===============================
// Build Mixed Question Bank
// ===============================

const ALL_FORMS = [];

modalConjugations.forEach(v=>{
  v.forms.forEach(([pronoun,form])=>{
    ALL_FORMS.push({verb:v.verb, pronoun, form});
  });
});

const QUESTION_BANK = ALL_FORMS.map(entry=>{
  const wrongPool = ALL_FORMS
    .map(f=>f.form)
    .filter(f=>f!==entry.form);

  const options = new Set([entry.form]);

  while(options.size < 4){
    options.add(wrongPool[Math.floor(Math.random()*wrongPool.length)]);
  }

  return {
    prompt:`${entry.pronoun} â€” ${entry.verb}`,
    options: shuffle([...options]),
    correct: entry.form
  };
});

// ===============================
// Game Variables
// ===============================

const COLS=7, ROWS=6;
let grid, current=1, pendingColumn=null, questionPool=shuffle([...QUESTION_BANK]);

function resetBoard(){
  grid=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  current=1;
  pendingColumn=null;
  questionPool=shuffle([...QUESTION_BANK]);
  renderBoard();
  updateTurn();
  $('#qtext').textContent='Pick a column to get a questionâ€¦';
  $('#answers').innerHTML='';
}

function renderBoard(){
  const b=$('#board'); b.innerHTML='';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const slot=document.createElement('div'); slot.className='slot';
      const disc=document.createElement('div'); disc.className='disc';
      if(grid[r][c]===1) disc.classList.add('red','show');
      if(grid[r][c]===2) disc.classList.add('yellow','show');
      slot.appendChild(disc); b.appendChild(slot);
    }
  }

  const cs=$('#colSelect'); cs.innerHTML='';
  for(let c=0;c<COLS;c++){
    const btn=document.createElement('button'); btn.className='col-btn';
    btn.textContent=`Col ${c+1}`;
    if(grid[0][c]!==0) btn.disabled=true;
    if(pendingColumn===c) btn.classList.add('active');
    btn.onclick=()=> chooseColumn(c);
    cs.appendChild(btn);
  }
}

function updateTurn(){ $('#turn').textContent=(current===1?'Red':'Yellow')+' to move'; }

function chooseColumn(col){
  pendingColumn=col;
  renderBoard();
  askQuestion();
}

function getNextQuestion(){
  if(questionPool.length===0) questionPool=shuffle([...QUESTION_BANK]);
  return questionPool.pop();
}

function askQuestion(){
  if(pendingColumn===null) return;
  const currentQuestion=getNextQuestion();
  $('#qtext').textContent=`Column ${pendingColumn+1}: ${currentQuestion.prompt}`;
  const answers=$('#answers'); answers.innerHTML='';
  const opts=shuffle(currentQuestion.options);

  for(const opt of opts){
    const btn=document.createElement('button');
    btn.className='answer';
    btn.textContent=opt;
    btn.onclick=()=>{
      const ok = (opt===currentQuestion.correct);
      if(!ok){ btn.classList.add('wrong'); }
      finishQuestion(ok);
    };
    answers.appendChild(btn);
  }
}

function finishQuestion(correct){
  if(correct){
    toast('âœ… Correct!');
    dropDisc(pendingColumn);
    if(checkWinner(current)){
      toast((current===1?'Red':'Yellow')+' wins! ðŸŽ‰',5000);
      $('#turn').textContent = (current===1?'Red':'Yellow')+' WINS!';
      disableColumns();
      return;
    }
  } else {
    toast('âŒ Incorrect â€” turn passes');
  }
  pendingColumn=null;
  $('#answers').innerHTML='';
  $('#qtext').textContent='Pick a column to get a questionâ€¦';
  current = 3 - current;
  updateTurn();
  renderBoard();
}

function dropDisc(col){
  let row = ROWS-1;
  while(row>=0 && grid[row][col]!==0) row--;
  if(row<0){ pendingColumn=null; return; }
  grid[row][col]=current;
  renderBoard();
  const idx = row*COLS + col;
  const disc = $$('#board .disc')[idx];
  requestAnimationFrame(()=>disc.classList.add('show'));
}

function checkWinner(player){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(grid[r][c]!==player) continue;
      if(c+3<COLS && grid[r][c+1]===player && grid[r][c+2]===player && grid[r][c+3]===player) return true;
      if(r+3<ROWS && grid[r+1][c]===player && grid[r+2][c]===player && grid[r+3][c]===player) return true;
      if(r+3<ROWS && c+3<COLS && grid[r+1][c+1]===player && grid[r+2][c+2]===player && grid[r+3][c+3]===player) return true;
      if(r+3<ROWS && c-3>=0 && grid[r+1][c-1]===player && grid[r+2][c-2]===player && grid[r+3][c-3]===player) return true;
    }
  }
  return false;
}

function disableColumns(){ $$('#colSelect .col-btn').forEach(btn=>btn.disabled=true); }

$('#newGame').onclick=resetBoard;

resetBoard();

// Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js');
  });
}
</script>
</html>
